---
title: "Protocol Buffers (Protobuf): What It Is and Its Benefits for Developers"
description: Discover what Protocol Buffers (Protobuf) are, Google's data serialization technology. Learn its benefits, like performance, strong typing, and schema evolution, and see practical examples of how to use it in Go and TypeScript.
pubDate: 2025-04-25T00:00:00.000Z
author: Miguel Machado
layout: post
mainClass: proto
color: "#30638e"
tags: ['protobuf', 'serialization', 'performance', 'api', 'microservices', 'google', 'go', 'typescript']
slug: "protocol-buffers-protobuf-what-is-and-benefits"
draft: false
---

# Introduction

In modern development, efficient communication between services, microservices, and components directly impacts performance, maintainability, and scalability. Protocol Buffers (Protobuf), created by Google, offer a compact and flexible binary serialization solution.

## What Are Protocol Buffers (Protobuf)?

Protocol Buffers are a language-agnostic and platform-agnostic mechanism for serializing structured data. Unlike text-based formats (JSON, XML), Protobuf uses a compact binary format.

- **Schema based on `.proto` files**: defines fields and types once.
- **Code generation**: `protoc` generates optimized classes in various languages.
- **Binary Format**: reduces size and accelerates parsing.
- **Schema Evolution**: allows adding or removing fields without breaking backward and forward compatibility.

## How Does Protobuf Work?

1. **Define the Schema**: create a `.proto` file with your messages, fields, and types.
2. **Compile the Schema**: use the `protoc` compiler and plugins to generate code in Go, TypeScript, etc.
3. **Use the generated code**: import the classes/structs and call methods to serialize and deserialize.

## Installing and Configuring Protobuf

Before using Protobuf, you need to set up your environment with the appropriate tools:

### 1. Installing the `protoc` compiler

```bash
# macOS (using Homebrew)
brew install protobuf

# Ubuntu/Debian
sudo apt-get install protobuf-compiler

# Windows (using Chocolatey)
choco install protoc
```

### 2. Installing language-specific plugins

**For Go:**
```bash
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

**For TypeScript:**
```bash
npm install --save-dev @protobuf-ts/plugin
npm install --save @protobuf-ts/runtime
```

Make sure the executables are in the system PATH so the protoc compiler can find them.

## Practical Example: Complete Protobuf Usage Cycle

### 1. Defining the Schema (`person.proto`)
```protobuf
syntax = "proto3";
package tutorial;
option go_package = "example.com/protobuf-blog/tutorial";

// Defines the Person message
message Person {
  // Message fields with types and unique numbers (tags)
  string name = 1;
  int32 id = 2;
  string email = 3;

  // Enum for phone types
  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  // Nested message for phone numbers
  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  // Repeated field (list) of phone numbers
  repeated PhoneNumber phones = 4;
}
```

### 2. Compiling the Schema
```bash
# For Go
protoc --proto_path=. --go_out=. --go_opt=module=example.com/protobuf-blog person.proto
```
```bash
# For TypeScript
protoc \
  --plugin="protoc-gen-ts=./node_modules/.bin/protoc-gen-ts" \
  --ts_out="." \
  --proto_path=. \
  person.proto
```

### 3. Using the Generated Code

**Go**
```go
package main
import (
    "fmt"
    "log"
    // Imports the protobuf package generated from person.proto
    "example.com/protobuf-blog/tutorial"
    // Imports the Protobuf runtime library for Go, needed for Marshal/Unmarshal
    "google.golang.org/protobuf/proto"
)
func main() {
    // Creates an instance of the 'Person' struct generated by protoc
    person := &tutorial.Person{
        Id:    123,                    // Sets the 'id' field
        Name:  "John Smith",           // Sets the 'name' field
        Email: "john.smith@example.com", // Sets the 'email' field
        Phones: []*tutorial.Person_PhoneNumber{ // Creates a slice (list) of 'PhoneNumber'
            {
                Number: "11-99999-8888",           // Sets the number
                Type: tutorial.Person_MOBILE, // Sets the type using the generated enum
            },
        },
    }

    // Serializes the 'person' instance to Protobuf binary format.
    // 'proto.Marshal' returns a []byte and an error.
    data, err := proto.Marshal(person)
    if err != nil {
        // If an error occurs during serialization, log and terminate
        log.Fatalf("Error serializing: %v", err)
    }

    // Prints the size of the resulting binary data (in bytes)
    fmt.Println("Serialized data size (bytes):", len(data))

    // Creates a new empty 'Person' instance to receive the deserialized data
    receivedPerson := &tutorial.Person{}

    // Deserializes the binary data ('data') back to the 'receivedPerson' struct.
    // 'proto.Unmarshal' receives the bytes and a pointer to the destination struct.
    if err := proto.Unmarshal(data, receivedPerson); err != nil {
        // If an error occurs during deserialization, log and terminate
        log.Fatalf("Error deserializing: %v", err)
    }

    // Accesses the fields of 'receivedPerson' that was filled by deserialization.
    // Getters (GetId, GetName, etc.) are generated by protoc.
    fmt.Println("ID:", receivedPerson.GetId())
    fmt.Println("Name:", receivedPerson.GetName())
    fmt.Println("Email:", receivedPerson.GetEmail())

    // Checks if the phones list is not empty before accessing it
    if len(receivedPerson.GetPhones()) > 0 {
        // Accesses the first phone in the 'Phones' slice
        phone := receivedPerson.GetPhones()[0]
        // Prints the number and type of the phone, using the generated getters
        fmt.Printf("Phone: %s (%s)\n", phone.GetNumber(), phone.GetType())
    }
}
```

**TypeScript**
```typescript
// Imports the 'Person' class and 'Person_PhoneType' enum from the generated 'person.ts' file
import { Person, Person_PhoneType } from "./person";
// Imports the 'Person_PhoneNumber' interface/type (nested message) from the same generated file
import { Person_PhoneNumber } from "./person";

// Creates a TypeScript object literal that corresponds to the 'Person' message structure defined in .proto
const personData: Person = {
    id: 123,                       // Sets the 'id' property
    name: "John Smith",            // Sets the 'name' property
    email: "john.smith@example.com", // Sets the 'email' property
    phones: [                      // Creates an array for the 'phones' property
        // Creates an object for the phone number.
        // 'as Person_PhoneNumber' is a type assertion to ensure conformity with the generated interface.
        { number: "11-99999-8888", type: Person_PhoneType.MOBILE } as Person_PhoneNumber,
    ],
};

// Serializes the 'personData' object to Protobuf binary format.
// The static 'toBinary' method is generated in the 'Person' class and returns a Uint8Array.
const binaryData: Uint8Array = Person.toBinary(personData);

// Prints the size of the resulting byte array
console.log("Serialized data size (bytes):", binaryData.length);

// Deserializes the binary data ('binaryData') back to a 'Person' object.
// The static 'fromBinary' method is generated in the 'Person' class.
const receivedPerson: Person = Person.fromBinary(binaryData);

// Accesses the properties of 'receivedPerson' that was created from the binary data
console.log("ID:", receivedPerson.id);
console.log("Name:", receivedPerson.name);
console.log("Email:", receivedPerson.email);

// Checks if the 'phones' array is not empty
if (receivedPerson.phones.length) {
    // Accesses the first phone object in the array
    const phone = receivedPerson.phones[0];
    // Prints the number and type of the phone.
    // 'Person_PhoneType[phone.type]' converts the numeric enum value back to its string representation (e.g., 'MOBILE').
    console.log(`Phone: ${phone.number} (${Person_PhoneType[phone.type]})`);
}
```

## Main Benefits of Protobuf

- **Superior performance**
  Reduced size and fast serialization reduce bandwidth and latency.
- **Language independence**
  Single schema generates native code in Go, TypeScript, and other languages.
- **Schema Evolution**
  Add fields without breaking backward and forward compatibility.
- **Strong typing**
  Errors are caught at compile time, avoiding inconsistencies.
- **Automatic code generation**
  `protoc` generates boilerplate, speeding up development.

## When NOT to Use Protobuf

- Small and infrequent payloads
- Integration with legacy systems without Protobuf toolchain
- Logs or configurations that need to be human-readable

## Benchmark: JSON vs Protobuf
```go
package main
import (
    "encoding/json"
    "fmt"
    "time"
    "google.golang.org/protobuf/proto"
    "example.com/protobuf-blog/tutorial"
)
func main() {
    p := &tutorial.Person{
        Id:    123,
        Name:  "Benchmark",
        Email: "benchmark@example.com",
        Phones: []*tutorial.Person_PhoneNumber{
            {Number: "11-99999-8888", Type: tutorial.Person_MOBILE},
        },
    }
    start := time.Now()
    j, _ := json.Marshal(p)
    dtJSON := time.Since(start)
    start = time.Now()
    b, _ := proto.Marshal(p)
    dtPB := time.Since(start)
    fmt.Printf("JSON: %d bytes, %v\n", len(j), dtJSON)
    fmt.Printf("Protobuf: %d bytes, %v\n", len(b), dtPB)
}
```

**Benchmark Results:**
*   **JSON:**
    *   Size: 124 bytes
    *   Serialization time: 120µs
*   **Protobuf:**
    *   Size: 45 bytes
    *   Serialization time: 30µs

> **NOTE:** This benchmark is a simplified demonstration comparing serialization of a basic structure. In real cases, with more complex structures and larger data volumes, the differences tend to be even more significant. For more accurate performance evaluations, it's recommended to run tests with data representative of your application.

## Integration with gRPC

gRPC is a high-performance RPC (Remote Procedure Call) framework that uses Protobuf as its default serialization format. This combination offers significant advantages for distributed systems.

### Advantages of gRPC + Protobuf Integration

- **Well-defined contracts**: Clear schemas between client and server
- **Bidirectional streaming**: Support for continuous communication in both directions
- **Automatic stub generation**: Client and server generated from the same `.proto` file
- **HTTP/2**: Uses multiplexing and compressed headers for greater efficiency
- **Interceptors**: Middleware for authentication, logging, rate limiting, etc.

## Common Use Cases

- Communication between microservices with gRPC
- High-performance internal APIs
- Compact data storage
- Mobile-Backend communication
- Frontend-Backend via gRPC-Web

## Conclusion

Protocol Buffers offer performance, efficiency, and scalability in distributed systems. Despite the initial curve, the gains in maintainability and speed justify the investment in Go and TypeScript.

## Additional Resources

- [Official Protocol Buffers Documentation](https://developers.google.com/protocol-buffers/docs/overview)
- [grpc.io - Official gRPC Documentation](https://grpc.io/docs/)
- [GitHub: Protobuf TypeScript](https://github.com/protobufjs/protobuf.js)
- [GitHub: Protobuf Go](https://github.com/protocolbuffers/protobuf-go)

**What about you?** Do you already use Protobuf in production? Share your experiences in the comments!
